## 1. 도메인 모델 시작하기

### 1.1 도메인

도메인은 간단하게 정의하면 해결하고자 하는 문제 영역이다. 한 도메인은 다시 하위 도메인으로 나눌 수 있다. 주문 도메인은 주문을 처리하기 위해 결제, 배송, 혜택 등의 하위 도메인의 기능이 엮이게 된다.
특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공하는 모든 기능을 직접 구현하는 것은 아니다. 결제를 직접 구현하기보다 결제 대행업체를 이용하여 처리하기도 한다.
하위 도메인을 구성할지 여부는 요구사항, 현재 상황에 따라 달라진다. 직접 모든 것을 구현하기 어렵다면 기능을 제공하는 솔루션을 사용할 수도 있다. 

### 1.2 도메인 전문가와 개발자 간 지식 공유

개발자는 요구사항을 분석하고 설계하여 코드를 작성하며 테스트하고 배포하는 과정을 거친다. 이 과정의 가장 첫번째인 요구사항을 올바르게 이해하고 설계하는 과정은 매우 중요하다.
잘못된 요구사항으로 설계의 변경이 발생하기도 하고 엉뚱한 기능을 만들기도 하기 때문이다. 작성한 코드를 변경하는 것은 많은 시간이 소요되며 일정에도 영향을 미친다. 그래서 요구사항을 올바르게 이해하는 것은 중요하다.
요구사항을 올바르게 이해하기 위한 노력은 무엇이 있을까? 바로 올바른 커뮤니케이션을 하는 것이다. 다른 이해당사자들과 많은 커뮤니케이션을 하며 도메인 지식을 갖추어야 한다.

### 1.3 도메인 모델

도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. 개념 모델을 이용해서 바로 코드를 작성할 수 있는 것은 아니기 때문에 구현 기술에 맞는 구현 모델이 따로 필요하다.
개념 모델과 구현 모델은 서로 다른 것이지만 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다.

![도메인모델](/src/main/resources/static/images/domain.png)

### 1.4 도메인 모델 패턴

일반적인 애플리케이션의 아키텍쳐는 네 개의 영역으로 구성된다.

- 표현
  - 사용자의 요청을 처리하고 정보를 보여준다.
- 응용
  - 사용자가 요청한 기능을 실행한다. 도메인 계층을 조합해서 기능을 실행한다.
- 도메인
  - 도메인 규칙을 구현한다.
- 인프라스트럭처
  - 데이터베이스나 메시징 시스템과 같은 외부 시스템과 연동을 처리한다.

도메인 계층은 도메인의 핵심 규칙을 구현한다. 주문 도메인의 경우 '출고 전에 배송지를 변경 할 수 있다.'라는 규칙과 '주문 취소는 배송 전에만 할 수 있다.'라는 규칙을 구현한 코드가 도메인 계층에 위치하게 된다.
이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다.

```java
public void changeShippingInfo(ShippingInfo shippingInfo) {
    if (!state.isShippingChangeable()) {
        throw new IllegalStateException("can't change shipping in " + state);
    }
    this.shippingInfo = shippingInfo;
}
```

위의 코드를 살펴보면 주문 도메인의 일부 기능을 작성한 것이다. 배송지를 변경하려면 출고 전에만 가능하다는 도메인 규칙을 Order 도메인에서 구현하고 있다.
핵심적인 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.

### 1.5 도메인 모델 도출

도메인 모델의 이해없이 코딩을 하기는 어렵다. 요구사항과 관련자의 대화를 통해 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 한다.

- 최소 한 종류 이상의 상품을 주문해야 한다.
- 한 상품을 한 개 이상 주문할 수 있다.
- 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- 주문할 때 배송지 정보를 반드시 지정해야 한다.
- 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
- 출고를 하면 배송지를 변경할 수 없다.
- 출고 전에 주문을 취소할 수 있다.
- 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.

Order 도메인에서 요구사항을 확인하고 주문과 관련한 기능을 구현할 수 있다. '출고 전에 주문을 취소할 수 있다'라는 요구사항은 주문상태에 따라 취소여부를 확인하면 된다.
이런 것처럼 요구사항에 알맞은 기능을 구현하기 위해서는 도메인을 이해하는 것이 중요하다.

```java
public void cancel() {
    verifyNotYetShipped();
    this.state = OrderState.CANCELED;
}

private void verifyNotYetShipped() {
    if (state != OrderState.PAYMENT_WAITING && state != OrderState.PREPARING) {
        throw new IllegalStateException("already shipped");
    }
}
```

### 1.6 엔티티와 밸류

도출한 모델은 엔티티와 밸류로 구분할 수 있다. 엔티티와 밸류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 둘의 차이를 이행하는 것은 중요하다.

#### 1.6.1 엔티티

엔티티는 식별자를 가지고 있는 것이 가장 큰 특징이다. 엔티티 객체마다 고유한 식별자를 가지고 있다. 주문 도메인에서 주문번호는 고유하게 주문을 식별할 수 있어야 한다.
식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같은면 두 엔티티는 같다고 할 수 있다. equals(), hashCode() 메서드를 구현할 수 있다.

#### 1.6.2 엔티티의 식별자 생성

엔티티 식별자를 생성하는 다양한 방식
- 특정 규칙
- UUID
- 직접 입력
- 일련번호 사용

#### 1.6.3 밸류 타입

밸류 타입은 식별자를 가지고 있지 않고 데이터를 표현하고 있다. 밸류 타입은 응집력 있게 데이터를 표현하기에 적절하다.

```java
private String receiverName;        // 받는 사람 이름
private String receiverPhoneNumber; // 받는 사람 핸드폰 번호
```

Receiver 라는 밸류 타입을 생성하고 받는 사람으로 표현하고 값 객체로 분리할 수 있다.

```java
public Money add(Money money) {
    return new Money(this.value + money.getValue());
}
```

Money처럼 데이터를 변경하는 경우 기존 데이터를 변경하기 보다 새로운 객체를 생성하여 반환하는 방식을 선호한다. 데이터 변경 기능을 제공하지 않는 타입을 불변이라고 표현한다.
불변인 객체를 사용하는 이유는 안전한 코드를 작성할 수 있다는 데 있다. 

#### 1.6.4 엔티티 식별자와 밸류 타입

식별자의 실제 데이터는 String 같은 문자열로 구성된 경우가 많다. (신용카드 번호, 이메일) Money가 단순 숫자가 아닌 돈이라는 것을 의미하는 것처럼 식별자를 위한 밸류 타입을 사용해서 의미를 잘 드러나도록 할 수 있다.
Order의 식별자로 String 대신 OrderNo라는 밸류 타입을 사용하면 해당 필드가 주문번호라는 것을 알 수 있다.
