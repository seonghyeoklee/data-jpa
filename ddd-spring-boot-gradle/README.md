## 1. 도메인 모델 시작하기

### 1.1 도메인

도메인은 간단하게 정의하면 해결하고자 하는 문제 영역이다. 한 도메인은 다시 하위 도메인으로 나눌 수 있다. 주문 도메인은 주문을 처리하기 위해 결제, 배송, 혜택 등의 하위 도메인의 기능이 엮이게 된다.
특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공하는 모든 기능을 직접 구현하는 것은 아니다. 결제를 직접 구현하기보다 결제 대행업체를 이용하여 처리하기도 한다.
하위 도메인을 구성할지 여부는 요구사항, 현재 상황에 따라 달라진다. 직접 모든 것을 구현하기 어렵다면 기능을 제공하는 솔루션을 사용할 수도 있다. 

### 1.2 도메인 전문가와 개발자 간 지식 공유

개발자는 요구사항을 분석하고 설계하여 코드를 작성하며 테스트하고 배포하는 과정을 거친다. 이 과정의 가장 첫번째인 요구사항을 올바르게 이해하고 설계하는 과정은 매우 중요하다.
잘못된 요구사항으로 설계의 변경이 발생하기도 하고 엉뚱한 기능을 만들기도 하기 때문이다. 작성한 코드를 변경하는 것은 많은 시간이 소요되며 일정에도 영향을 미친다. 그래서 요구사항을 올바르게 이해하는 것은 중요하다.
요구사항을 올바르게 이해하기 위한 노력은 무엇이 있을까? 바로 올바른 커뮤니케이션을 하는 것이다. 다른 이해당사자들과 많은 커뮤니케이션을 하며 도메인 지식을 갖추어야 한다.

### 1.3 도메인 모델

도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. 개념 모델을 이용해서 바로 코드를 작성할 수 있는 것은 아니기 때문에 구현 기술에 맞는 구현 모델이 따로 필요하다.
개념 모델과 구현 모델은 서로 다른 것이지만 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다.

![도메인모델](/src/main/resources/static/images/domain.png)

### 1.4 도메인 모델 패턴

일반적인 애플리케이션의 아키텍쳐는 네 개의 영역으로 구성된다.

- 표현
  - 사용자의 요청을 처리하고 정보를 보여준다.
- 응용
  - 사용자가 요청한 기능을 실행한다. 도메인 계층을 조합해서 기능을 실행한다.
- 도메인
  - 도메인 규칙을 구현한다.
- 인프라스트럭처
  - 데이터베이스나 메시징 시스템과 같은 외부 시스템과 연동을 처리한다.

도메인 계층은 도메인의 핵심 규칙을 구현한다. 주문 도메인의 경우 '출고 전에 배송지를 변경 할 수 있다.'라는 규칙과 '주문 취소는 배송 전에만 할 수 있다.'라는 규칙을 구현한 코드가 도메인 계층에 위치하게 된다.
이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다.

```java
public void changeShippingInfo(ShippingInfo shippingInfo) {
    if (!state.isShippingChangeable()) {
        throw new IllegalStateException("can't change shipping in " + state);
    }
    this.shippingInfo = shippingInfo;
}
```

위의 코드를 살펴보면 주문 도메인의 일부 기능을 작성한 것이다. 배송지를 변경하려면 출고 전에만 가능하다는 도메인 규칙을 Order 도메인에서 구현하고 있다.
핵심적인 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.

### 1.5 도메인 모델 도출

도메인 모델의 이해없이 코딩을 하기는 어렵다. 요구사항과 관련자의 대화를 통해 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 한다.

- 최소 한 종류 이상의 상품을 주문해야 한다.
- 한 상품을 한 개 이상 주문할 수 있다.
- 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
- 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
- 주문할 때 배송지 정보를 반드시 지정해야 한다.
- 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
- 출고를 하면 배송지를 변경할 수 없다.
- 출고 전에 주문을 취소할 수 있다.
- 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.

Order 도메인에서 요구사항을 확인하고 주문과 관련한 기능을 구현할 수 있다. '출고 전에 주문을 취소할 수 있다'라는 요구사항은 주문상태에 따라 취소여부를 확인하면 된다.
이런 것처럼 요구사항에 알맞은 기능을 구현하기 위해서는 도메인을 이해하는 것이 중요하다.

```java
public void cancel() {
    verifyNotYetShipped();
    this.state = OrderState.CANCELED;
}

private void verifyNotYetShipped() {
    if (state != OrderState.PAYMENT_WAITING && state != OrderState.PREPARING) {
        throw new IllegalStateException("already shipped");
    }
}
```

### 1.6 엔티티와 밸류

도출한 모델은 엔티티와 밸류로 구분할 수 있다. 엔티티와 밸류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 둘의 차이를 이행하는 것은 중요하다.

#### 1.6.1 엔티티

엔티티는 식별자를 가지고 있는 것이 가장 큰 특징이다. 엔티티 객체마다 고유한 식별자를 가지고 있다. 주문 도메인에서 주문번호는 고유하게 주문을 식별할 수 있어야 한다.
식별자는 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같은면 두 엔티티는 같다고 할 수 있다. equals(), hashCode() 메서드를 구현할 수 있다.

#### 1.6.2 엔티티의 식별자 생성

엔티티 식별자를 생성하는 다양한 방식
- 특정 규칙
- UUID
- 직접 입력
- 일련번호 사용

#### 1.6.3 밸류 타입

밸류 타입은 식별자를 가지고 있지 않고 데이터를 표현하고 있다. 밸류 타입은 응집력 있게 데이터를 표현하기에 적절하다.

```java
private String receiverName;        // 받는 사람 이름
private String receiverPhoneNumber; // 받는 사람 핸드폰 번호
```

Receiver 라는 밸류 타입을 생성하고 받는 사람으로 표현하고 값 객체로 분리할 수 있다.

```java
public Money add(Money money) {
    return new Money(this.value + money.getValue());
}
```

Money처럼 데이터를 변경하는 경우 기존 데이터를 변경하기 보다 새로운 객체를 생성하여 반환하는 방식을 선호한다. 데이터 변경 기능을 제공하지 않는 타입을 불변이라고 표현한다.
불변인 객체를 사용하는 이유는 안전한 코드를 작성할 수 있다는 데 있다. 

#### 1.6.4 엔티티 식별자와 밸류 타입

식별자의 실제 데이터는 String 같은 문자열로 구성된 경우가 많다. (신용카드 번호, 이메일) Money가 단순 숫자가 아닌 돈이라는 것을 의미하는 것처럼 식별자를 위한 밸류 타입을 사용해서 의미를 잘 드러나도록 할 수 있다.
Order의 식별자로 String 대신 OrderNo라는 밸류 타입을 사용하면 해당 필드가 주문번호라는 것을 알 수 있다.

#### 1.6.5 도메인 모델에 set 메서드 넣지 않기

get/set 메서드를 습관적으로 추가하기도 한다. 하지만 도메인 모델에 set 메서드를 추가하는 것은 좋지 않은 버릇이다. set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
단순하게 set 메서드로 도메인 상태를 변경하게 되면 도메인 지식이 코드를 표현하는 것이 사라지고 set 메서드로 도배될 것이다. 그리고 객체를 생성할 때 set 메서드로 값을 전달한다면 객체가 온전하지 못할 가능성이 있다.
null로 채워지는 값들이 문제가 될 가능성이 높아진다. 이렇게 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 데이터를 모두 전달하여 생성해야 한다. 생성자에서 데이터에 대한 검증을 진행하고 객체를 생성하면 된다. 

### 1.7 도메인 용어와 유비쿼터스 언어

코드를 작성할 때 도메인에서 사용하는 용어는 매우 중요하다. 도메인 용어를 코드에 반영하지 않으면 코드의 의미를 해석하는데 부담이 된다.
주문 상태를 단순하게 Step으로 나열하게 된다면 개발자는 Step에 맞는 주문상태를 변환하며 개발해야 하는 번거로움이 생긴다. 도메인 용어를 사용하여 코드의 가독성을 높이고 분석하는데 시간을 줄여주도록 하자.

에릭 에반스의 도메인 주도 설계에는 유비쿼터스 언어라는 용어를 사용했는데 모든 도메인 이해당사자가 사용하는 공통의 언어를 만들고 대화, 문서, 코드, 테스트 등 모든 곳에서 사용하도록 강조했다.
의사소통 과정에서 불필요한 용어의 모호함을 없애고 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다. 개발 과정에서 도메인에 대한 이해가 높아진다면 새로운 용어를 반영하는 방법도 존재한다.
도메인에서 사용하는 용어의 의미를 전달하는 영단어를 찾는 것이 어려울 수 있다. 또는 비슷한 영단어로 어느 단어를 사용할 지 고심하기도 한다. 쉬운 과정은 아니지만 알맞은 도메인 용어를 찾아서 사용하는 것은 중요하기 때문에 많은 시간을 투자해도 좋다.

## 2. 아케텍처 개요

### 2.1 네 개의 영역

웹 애플리케이션에서 표현 영역은 HTTP 요청을 받아 응용 영역에 전달하고 처리 결과를 HTTP 응답으로 변환하여 전송한다. 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 구현한다.
주로 서비스의 핵심 비즈니스 로직을 실행한다. 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다. 인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다. DB와 연동을 처리하고
메시징 큐에 메시지를 전송하는 등의 작업을 수행한다.

### 2.2 계층 구조 아키텍처

> 표현 -> 응용 -> 도메인 -> 인프라스트럭처

네 영역을 구성할 때 사용하는 아키텍처 모습이다. 계층 구조로 구성되어 있고 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다. (응용 -> 인프라스트럭처) 여기서 주의해야 하는 점은 인프라스트럭처에 의존하게 되면 테스트의 어려움과 기능 확장에 어려움이 존재한다.
특정 기술이 응용 계층에 사용된다면 테스트하기 위해 셋팅을 진행해야 하고 이미 기존 기술에 의존하고 있기 때문에 변경에 취약하다.

### 2.3 DIP

가격 할인 계산이 필요한 로직이 있는 서비스는 두 가지 작은 기능이 존재한다. 첫번째 고객 정보를 조회하고 두번째 할인을 실행해야 한다. 가격 할인을 위해 두 가지 하위 기능이 존재한다고 했을 때, 가격 할인은 고수준 모듈, 하위 기능은 저수준 모듈이 된다.
고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 하지만 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제, 구현의 변경과 테스트가 어렵다는 문제가 발생한다.

DIP는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 반대로 의존을 바꾸려면 추상화한 인터페이스를 사용하면 된다. 구체적인 구현체에 의존하는 것이 아니라
인터페이스의 역할에 의존하도록 변경하면 된다. 

### 2.4 도메인 영역의 주요 구성요소

도메인의 영역을 구성하는 요소는 다음과 같다.

- 엔티티(Entity) : 고유한 식별자를 가지고 있고 자신의 라이프 사이클을 가진다. 주문, 회원, 상품과 같은 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 관련된 기능을 제공한다.
- 밸류(Value) : 고유한 식별자를 갖지 않는 객체로 개념적인 하나의 값을 표현할 때 사용한다. 주소, 금액과 같은 타입이 밸류 타입이다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다.
- 애그리거트(Aggregate) : 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다.
- 리포지터리(Repository) : 도메인 모델의 영속성을 담당한다. 
- 도메인 서비스(Domain Service) : 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다.

#### 2.4.2 에그리거트

도메인이 커질수록 개발할 도메인 모델이 커지면서 많은 엔티티와 밸류가 출현한다. 엔티티와 밸류 개수가 많아질수록 모델은 점점 더 복잡해진다. 도메인 모델이 복잡해지면
개발자가 전체 구조가 아닌 한 개 엔티티와 밸류에만 집중하는 상황이 발생한다. 이때 상위 수준에서 모델을 관리하지 않고 개별 요소에만 초점을 맞추다 보면, 큰 수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리하지 못하는 상황에 빠질 수 있다.

도메인 모델을 상위 수준에서 볼 수 있어야 전체 모델과 개별 모델을 이해하는데 도움이 된다. 도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 바로 에그리거트이다.
에그리거트는 관련 객체를 하나로 묶은 군집이다. 주문 도메인은 주문, 배송지 정보, 주문자, 주문 등록, 결제 금액 등의 하위 모델로 구성된다. 이 하위 개념을 표현한 모델을 하나로 묶어서 주문이라는 상위 개념으로 표현할 수 있다.

에그리거트를 사용하면 군집 단위로 모델을 바라볼 수 있다. 애그리거트 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다. 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.
