웹의 기본적인 아키텍쳐의 흐음은 다음과 같다.

> 클라이언트 - 서버 - 데이터베이스

서비스의 초기에는 기본적인 아키텍쳐를 이용하여 서비스를 구성할 수 있겠지만, 클라이언트가 증가하면 서버가 처리할 수 있는 한계치에 다다르게 된다.
이런 경우에 서버의 성능을 확장하는 스케일 업, 서버의 대수를 증가하여 부하를 분산하는 스케일 아웃 등의 방법이 있다. 

스케일 업은 단순하게 서버의 성능을 확장하기 때문에 비교적 단순하고 유지보수가 쉽다는 장점이 존재하지만 확장에 제약이 따르고 1대의 서버만을 사용하는 경우 다운타임이 발생하게 된다.
스케일 아웃은 여러 서버에 부하분산을 필요로 하고 확장에 훨씬 유리하며 장애 탄력성이 존재한다.

서버는 클라이언트와 통신할 떄 상태를 가지고 있지 않는다. 즉, 서버가 스케일 아웃하는 경우 상태를 가지고 있지 않기 때문에 무한한 확장이 가능하다. 하지만 데이터베이스는 어떨까?
데이터베이스는 데이터 상태를 관리하고 있기 때문에 서버보다 스케일 아웃하는 과정이 복잡하고 많은 비용이 발생한다.

만약 대용량 트래픽을 처리해야 한다면 어떤 문제점들이 존재할까?

- 하나의 서버가 아닌 어려대의 서버, 데이터베이스를 사용함
- 여러개의 서버에서 유입되는 데이터의 일관성을 보장해야함
- 여러 서비스에서 사용되기 때문에 높은 복잡도를 가짐

데이터베이스에서 조회와 쓰기의 적절한 트레이드 오프가 필요하다. 정규화를 통해 데이터의 중복을 제거하고 변경의 포인트를 한곳으로 가져갈 수 있지만 조회시 원본 데이터를 참조해야 한다.
비정규화는 데이터의 중복을 허용하고 데이터 변경 시 많은 쓰기가 발생할 수 있지만 조회 성능을 향상 시킬수 있다. 따라서 현재 서비스의 특징에 맞게 적절한 트레이드 오프가 필요하다.
조회와 쓰기를 분리하여 생각하게 되면 서비스의 아키텍쳐나 최적화하는 방법 등이 달라질 수 있다.

메모리, 디스크는 데이터 저장용으로 사용한다. 데이터는 영속화를 위해 결국 디스크에 저장되어야 한다. 하지만 디스크는 메모리에 비하면 훨씬 느린 성능을 가진다.
결국 데이터베이스 성능의 핵심은 디스크 접근을 최소화 하는 것이다. 캐시를 사용하는 등의 방법으로 디스크 I/O를 최대한 줄이는 것이 중요하다. (메모리 캐시 히트율을 높이는 것)

데이터 쓰거나 갱신하는 행위도 바로 디스크에 쓰지 않고 메모리에 저장하고 한번에 처리할 수 있다. 하지만 메모리는 전원이 차단되는 경우 데이터 유실이 발생하게 된다.
이러한 점을 보완하는 WAL(Write Ahead Log)를 사용하여 데이터가 유실되지 않도록 보완할 수 있다.

### 인덱스

인덱스는 정렬된 자료구조를 가지고 탐색 범위를 최소화 하는데 사용된다. 즉 조회 성능을 향상시키기 위한 자료구조로 사용된다. 인덱스를 생성하게 되면 별도의 인덱스 테이블이 생성되고 인덱스 컬럼을 정렬하여 보관한다.
정렬되어 있기 때문에 탐색의 범위를 최소화하여 데이터를 찾을 수 있도록 도와준다. 하지만 정렬된 인덱스를 유지하기 위해 삽입, 갱신의 성능은 저하된다.

#### 인덱스 자료구조

HashMap
- 단건 검색 속도 O(1)
- 범위 탐색 O(N)
- 전방 일치 탐색 불가 (like 검색)

List
- 정렬되지 않은 리스트 탐색은 O(N)
- 정렬된 리스트 탐색은 O(logN)
- 정렬되지 않은 리스트의 정렬 시간 복잡도는 O(N) ~ O(N * logN)
- 삽입 / 삭제 비용이 매우 높다

Tree
- 트리 높이에 따라 시간 복잡도가 결정됨
- 트리의 높이를 최소화하는 것이 중요!
- 한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용

B+ Tree
- 삽입 / 삭제는 항상 균형을 이룸
- 하나의 노드가 여러 개의 자식 노드를 가질 수 있음
- 리프노드에만 데이터 존재, 연속적인 데이터 접근 시 유리

### 트랜잭션

데이터베이스를 사용하는 가장 큰 이유는 트랙잭션이라는 개념을 지원하기 때문이다. 실행되어야 하는 하나의 작업 단위로 하나의 작업을 안전하게 처리하도록 보장하는 것이다.
- 트랙잭션의 ACID 특징
  - 원자성 : 트랜잭션 내에서 실행된 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
  - 일관성 : 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
  - 격리성 : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
  - 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

### 트랜잭션 격리레벨

트랜잭션이 다른 트랜잭션에 영향을 미치게 되면 데이터의 정합성에 문제가 발생할 수 있다. 다음의 이상 현상이 발생할 수 있기때문에 트랜잭션의 격리레벨을 파악해야 한다. 

- Dirty Read
  - A 트랜잭션이 실행되는 도중에 값이 변경했다고 가정했을 때 B 트랜잭션이 그 값을 조회한 경우 커밋되지 않은 값을 조회하게 된 것이다. 그런데 A 트랜잭션이 실패하여 롤백하는 경우 B 트랜잭션은 실패한 A 트랜잭션의 값을 조회한 것이기 때문에 문제가 발생한다.
- Non Repeatable Read
  - A 트랜잭션에서 값을 조회하는 도중에 B 트랜잭션에서 값을 변경하는 경우에 A 트랜잭션은 처음 조회했던 값이 아닌 변경 된 값을 조회할 수 있다. 같은 데이터를 조회했는데 결과가 달라지게 된다.
- Phantom READ
  - Non Repeatable Read와 비슷하다. 같은 조건으로 데이터를 조회했을 때 없던 데이터가 조회되는 것을 의미한다.
