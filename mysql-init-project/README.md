웹의 기본적인 아키텍쳐의 흐음은 다음과 같다.

> 클라이언트 - 서버 - 데이터베이스

서비스의 초기에는 기본적인 아키텍쳐를 이용하여 서비스를 구성할 수 있겠지만, 클라이언트가 증가하면 서버가 처리할 수 있는 한계치에 다다르게 된다.
이런 경우에 서버의 성능을 확장하는 스케일 업, 서버의 대수를 증가하여 부하를 분산하는 스케일 아웃 등의 방법이 있다. 

스케일 업은 단순하게 서버의 성능을 확장하기 때문에 비교적 단순하고 유지보수가 쉽다는 장점이 존재하지만 확장에 제약이 따르고 1대의 서버만을 사용하는 경우 다운타임이 발생하게 된다.
스케일 아웃은 여러 서버에 부하분산을 필요로 하고 확장에 훨씬 유리하며 장애 탄력성이 존재한다.

서버는 클라이언트와 통신할 떄 상태를 가지고 있지 않는다. 즉, 서버가 스케일 아웃하는 경우 상태를 가지고 있지 않기 때문에 무한한 확장이 가능하다. 하지만 데이터베이스는 어떨까?
데이터베이스는 데이터 상태를 관리하고 있기 때문에 서버보다 스케일 아웃하는 과정이 복잡하고 많은 비용이 발생한다.

만약 대용량 트래픽을 처리해야 한다면 어떤 문제점들이 존재할까?

- 하나의 서버가 아닌 어려대의 서버, 데이터베이스를 사용함
- 여러개의 서버에서 유입되는 데이터의 일관성을 보장해야함
- 여러 서비스에서 사용되기 때문에 높은 복잡도를 가짐

데이터베이스에서 조회와 쓰기의 적절한 트레이드 오프가 필요하다. 정규화를 통해 데이터의 중복을 제거하고 변경의 포인트를 한곳으로 가져갈 수 있지만 조회시 원본 데이터를 참조해야 한다.
비정규화는 데이터의 중복을 허용하고 데이터 변경 시 많은 쓰기가 발생할 수 있지만 조회 성능을 향상 시킬수 있다. 따라서 현재 서비스의 특징에 맞게 적절한 트레이드 오프가 필요하다.
조회와 쓰기를 분리하여 생각하게 되면 서비스의 아키텍쳐나 최적화하는 방법 등이 달라질 수 있다.

메모리, 디스크는 데이터 저장용으로 사용한다. 데이터는 영속화를 위해 결국 디스크에 저장되어야 한다. 하지만 디스크는 메모리에 비하면 훨씬 느린 성능을 가진다.
결국 데이터베이스 성능의 핵심은 디스크 접근을 최소화 하는 것이다. 캐시를 사용하는 등의 방법으로 디스크 I/O를 최대한 줄이는 것이 중요하다. (메모리 캐시 히트율을 높이는 것)

데이터 쓰거나 갱신하는 행위도 바로 디스크에 쓰지 않고 메모리에 저장하고 한번에 처리할 수 있다. 하지만 메모리는 전원이 차단되는 경우 데이터 유실이 발생하게 된다.
이러한 점을 보완하는 WAL(Write Ahead Log)를 사용하여 데이터가 유실되지 않도록 보완할 수 있다.

### 인덱스

인덱스는 정렬된 자료구조를 가지고 탐색 범위를 최소화 하는데 사용된다. 즉 조회 성능을 향상시키기 위한 자료구조로 사용된다. 인덱스를 생성하게 되면 별도의 인덱스 테이블이 생성되고 인덱스 컬럼을 정렬하여 보관한다.
정렬되어 있기 때문에 탐색의 범위를 최소화하여 데이터를 찾을 수 있도록 도와준다. 하지만 정렬된 인덱스를 유지하기 위해 삽입, 갱신의 성능은 저하된다.

#### 인덱스 자료구조

HashMap
- 단건 검색 속도 O(1)
- 범위 탐색 O(N)
- 전방 일치 탐색 불가 (like 검색)

List
- 정렬되지 않은 리스트 탐색은 O(N)
- 정렬된 리스트 탐색은 O(logN)
- 정렬되지 않은 리스트의 정렬 시간 복잡도는 O(N) ~ O(N * logN)
- 삽입 / 삭제 비용이 매우 높다

Tree
- 트리 높이에 따라 시간 복잡도가 결정됨
- 트리의 높이를 최소화하는 것이 중요!
- 한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용

B+ Tree
- 삽입 / 삭제는 항상 균형을 이룸
- 하나의 노드가 여러 개의 자식 노드를 가질 수 있음
- 리프노드에만 데이터 존재, 연속적인 데이터 접근 시 유리
